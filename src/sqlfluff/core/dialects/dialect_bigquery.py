"""The BigQuery dialect.

This inherits from the ansi dialect, with changes as specified by
https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax
and
https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#string_and_bytes_literals
"""

from ..parser import (
    BaseSegment,
    NamedSegment,
    OneOf,
    Ref,
    Sequence,
    Bracketed,
    Delimited,
)

from .dialect_ansi import ansi_dialect


bigquery_dialect = ansi_dialect.copy_as("bigquery")

bigquery_dialect.patch_lexer_struct(
    [
        # Quoted literals can have r or b (case insensitive) prefixes, in any order, to
        # indicate a raw/regex string or byte sequence, respectively.  Allow escaped quote
        # characters inside strings by allowing \" with an optional even multiple of
        # backslashes in front of it.
        # https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#string_and_bytes_literals
        # Triple quoted variant first, then single quoted
        (
            "single_quote",
            "regex",
            r"([rR]?[bB]?|[bB]?[rR]?)?('''((?<!\\)(\\{2})*\\'|'{,2}(?!')|[^'])*(?<!\\)(\\{2})*'''|'((?<!\\)(\\{2})*\\'|[^'])*(?<!\\)(\\{2})*')",
            dict(is_code=True),
        ),
        (
            "double_quote",
            "regex",
            r'([rR]?[bB]?|[bB]?[rR]?)?(\"\"\"((?<!\\)(\\{2})*\\\"|\"{,2}(?!\")|[^\"])*(?<!\\)(\\{2})*\"\"\"|"((?<!\\)(\\{2})*\\"|[^"])*(?<!\\)(\\{2})*")',
            dict(is_code=True),
        ),
    ]
)

bigquery_dialect.add(
    DoubleQuotedLiteralSegment=NamedSegment.make(
        "double_quote", name="quoted_literal", type="literal", trim_chars=('"',),
    ),
    StartAngleBracketSegment=KeywordSegment.make('<',
                                                 name='start_angle_bracket',
                                                 type='start_angle_bracket'),
    EndAngleBracketSegment=KeywordSegment.make('>', name='end_angle_bracket',
                                               type='end_angle_bracket')
)

# Add additional datetime units
# https://cloud.google.com/bigquery/docs/reference/standard-sql/date_functions#extract
bigquery_dialect.sets("datetime_units").update(
    ["MICROSECOND", "DAYOFWEEK", "ISOWEEK", "ISOYEAR", "DATE", "DATETIME", "TIME"]
)

# Unreserved Keywords
bigquery_dialect.sets("unreserved_keywords").add("SYSTEM_TIME")
bigquery_dialect.sets("unreserved_keywords").add("STRUCT")
bigquery_dialect.sets("unreserved_keywords").remove("FOR")
# Reserved Keywords
bigquery_dialect.sets("reserved_keywords").add("FOR")


# BigQuery allows functions in INTERVAL
class IntervalExpressionSegment(BaseSegment):
    """An interval with a function as value segment."""

    type = "interval_expression"
    match_grammar = Sequence(
        "INTERVAL",
        OneOf(Ref("NumericLiteralSegment"), Ref("FunctionSegment")),
        OneOf(Ref("QuotedLiteralSegment"), Ref("DatetimeUnitSegment")),
    )


bigquery_dialect.replace(
    QuotedIdentifierSegment=NamedSegment.make(
        "back_quote", name="quoted_identifier", type="identifier", trim_chars=("`",)
    ),
    IntervalExpressionSegment=IntervalExpressionSegment,
    LiteralGrammar=OneOf(
        Ref("QuotedLiteralSegment"),
        Ref("DoubleQuotedLiteralSegment"),
        Ref("NumericLiteralSegment"),
        Ref("BooleanLiteralGrammar"),
        Ref("QualifiedNumericLiteralSegment"),
        Ref("NullKeywordSegment"),
    ),
    PostTableExpressionGrammar=Sequence(
        Sequence(
            "FOR", "SYSTEM_TIME", "AS", "OF", Ref("ExpressionSegment"), optional=True
        ),
        Sequence("WITH", "OFFSET", "AS", Ref("SingleIdentifierGrammar"), optional=True),
    ),
)


@bigquery_dialect.segment(replace=True)
class WildcardExpressionSegment(BaseSegment):
    """An extension of the star expression for Bigquery."""

    type = "wildcard_expression"
    match_grammar = Sequence(
        # *, blah.*, blah.blah.*, etc.
        Ref("WildcardIdentifierSegment"),
        # Optional EXCEPT or REPLACE clause
        # https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#select_replace
        Ref("ExceptClauseSegment", optional=True),
        Ref("ReplaceClauseSegment", optional=True),
    )


@bigquery_dialect.segment()
class ExceptClauseSegment(BaseSegment):
    """SELECT EXCEPT clause."""

    type = "select_except_clause"
    match_grammar = Sequence(
        "EXCEPT",
        Bracketed(
            Delimited(Ref("SingleIdentifierGrammar"), delimiter=Ref("CommaSegment"))
        ),
    )


@bigquery_dialect.segment()
class ReplaceClauseSegment(BaseSegment):
    """SELECT REPLACE clause."""

    type = "select_replace_clause"
    match_grammar = Sequence(
        "REPLACE",
        OneOf(
            # Multiple replace in brackets
            Bracketed(
                Delimited(
                    # Not *really* a select target element. It behaves exactly
                    # the same way however.
                    Ref("SelectTargetElementSegment"),
                    delimiter=Ref("CommaSegment"),
                )
            ),
            # Single replace not in brackets.
            Ref("SelectTargetElementSegment"),
        ),
    )


@bigquery_dialect.segment()
class FunctionDefinitionSegment(BaseSegment):
    type = "create_function_statement"
    match_grammar = Sequence(
        AnyNumberOf(
            Sequence(
                'LANGUAGE',
                # Not really a parameter, but best fit for now.
                Ref('ParameterNameSegment'),
                Sequence(
                    'OPTIONS',
                    Bracketed(
                        Delimited(
                            Sequence(
                                Ref('ParameterNameSegment'),
                                Ref('EqualsSegment'),
                                Anything()
                            ),
                            delimiter=Ref('CommaSegment')
                        )
                    ),
                    optional=True
                )
            ),
            # There is some syntax not implemented here,
            Sequence(
                'AS',
                OneOf(
                    Ref('DoubleQuotedLiteralSegment'),
                    Ref('QuotedLiteralSegment'),
                    Bracketed(
                        OneOf(
                            Ref('ExpressionSegment'),
                            Ref('SelectStatementSegment')
                        )
                    )
                ),
            )
        )
    ),
    DialectSpecificStatementsGrammar=OneOf(
        Ref('CreateModelStatementSegment'), Ref('DropModelStatementSegment')
    ),
    DialectSpecificTableExpressionGrammar=Ref('MLTableExpressionSegment')


@bigquery_dialect.segment(replace=True)
class DatatypeSegment(BaseSegment):
    """A data type segment.
    In particular here, this enabled the support for
    the STRUCT datatypes.
    """
    type = 'data_type'
    match_grammar = OneOf(  # Parameter type
        Ref('ParameterNameSegment'),  # Simple type
        Sequence(  # SQL UDFs can specify this "type"
            'ANY',
            'TYPE'
        ),
        Sequence(
            'ARRAY',
            Bracketed(
                Ref('DatatypeSegment'),
                bracket_type='angle'
            )
        ),
        Sequence(
            'STRUCT',
            Bracketed(
                Delimited(  # Comma-separated list of field names/types
                    Sequence(
                        Ref('ParameterNameSegment'),
                        Ref('DatatypeSegment')
                    ),
                    delimiter=Ref('CommaSegment')
                ),
                bracket_type='angle'
            ),
        )
    )


@bigquery_dialect.segment()
class CreateModelStatementSegment(BaseSegment):
    """A BigQuery `CREATE MODEL` statement."""
    type = 'create_model_statement'
    # https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create
    match_grammar = Sequence(
        'CREATE',
        Sequence(
            'OR',
            'REPLACE',
            optional=True
        ),
        'MODEL',
        Sequence(
            'IF',
            'NOT',
            'EXISTS',
            optional=True
        ),
        Ref('ObjectReferenceSegment'),
        Sequence(
            'OPTIONS',
            Bracketed(
                Delimited(
                    Sequence(
                        Ref('ParameterNameSegment'),
                        Ref('EqualsSegment'),
                        OneOf(
                            # This covers many but not all the extensive list of
                            # possible 'CREATE MODEL' optiona.
                            Ref('LiteralGrammar'),  # Single value
                            Bracketed(
                                # E.g. input_label_cols: list of column names
                                Delimited(
                                    Ref('QuotedLiteralSegment'),
                                    delimiter=Ref('CommaSegment')
                                ),
                                bracket_type='square',
                                optional=True
                            ),
                        )
                    ),
                    delimiter=Ref('CommaSegment')
                )
            ),
            optional=True
        ),
        'AS',
        Ref('SelectStatementSegment')
    )


@bigquery_dialect.segment()
class DropModelStatementSegment(BaseSegment):
    """A `DROP MODEL` statement."""
    type = 'drop_model_statement'
    # DROP MODEL <Model name> [IF EXISTS}
    # https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-drop-model
    match_grammar = Sequence(
        'DROP',
        'MODEL',
        Sequence(
            'IF',
            'EXISTS',
            optional=True
        ),
        Ref('ObjectReferenceSegment')
    )


@bigquery_dialect.segment()
class MLTableExpressionSegment(BaseSegment):
    """An ML table expression."""
    type = 'ml_table_expression'
    # E.g. ML.WEIGHTS(MODEL `project.dataset.model`)
    match_grammar = Sequence(
        'ML',
        Ref('DotSegment'),
        Ref('SingleIdentifierGrammar'),
        Bracketed(
            Sequence(
                'MODEL',
                Ref('ObjectReferenceSegment')
            ),
            OneOf(
                Sequence(
                    Ref('CommaSegment'),
                    Bracketed(
                        Ref('SelectStatementSegment')
                    )
                ),
                optional=True
            )
        )
    )